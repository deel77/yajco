## TODO: package
package printer;

import java.util.List;
import java.io.PrintWriter;
import visitor.Visitor;
import yajco.printer.PrinterException;
#foreach( $concept in $language.concepts )
#if( $language.name )
import ${language.name}.${Utilities.toUpperCaseIdent($concept.name)};
#else
import ${Utilities.toUpperCaseIdent($concept.name)};
#end
#end

public class Printer extends Visitor<PrintWriter> {

    private final String WHITE_SPACE = " ";
    private String indentString = "\t";
    private int indent = 0;
    private boolean inNewLine = true;

    public void print(Object o, PrintWriter writer) {
        inNewLine = true;
        visit(o, writer);
        writer.flush();
    }

#foreach( $concept in $language.concepts )
    @Override
    protected void visit${Utilities.toUpperCaseIdent($concept.name)}(${Utilities.toUpperCaseIdent($concept.name)} ${Utilities.toLowerCaseIdent($concept.name)}, PrintWriter p) {
 #set( $conceptPatterns = ${concept.patterns} )
 #set( $hasParenthesesPattern = ${Utilities.hasClassInList(${conceptPatterns},${parenthesesPatternClassName})} )
 #set( $parenthesesPattern = ${Utilities.getObjectFromList(${conceptPatterns},${parenthesesPatternClassName})} )
 #set( $notationCount = $concept.concreteSyntax.size() )
 #if( $hasParenthesesPattern )
        printNonSpacedLiteral("${parenthesesPattern.left}", p);
 #end
##
##
##
## Volanie viac specifickych metod ak niektory koncept dedi od aktualneho
##
 #set( $descendants = ${Utilities.getDirectDescendantConcepts(${concept}, ${language})} )
 #if( !$descendants.isEmpty() )
  #set( $ifBranchToken = "if" )
  #foreach( $descendant in $descendants )
        $ifBranchToken (${Utilities.toLowerCaseIdent($concept.name)} instanceof ${Utilities.toUpperCaseIdent($descendant.name)}) {
            visit${Utilities.toUpperCaseIdent($descendant.name)}((${Utilities.toUpperCaseIdent($descendant.name)}) ${Utilities.toLowerCaseIdent($concept.name)}, p);
        }
  #set( $ifBranchToken = "else if" )
  #end
        else {
 #end
##
##
## tvorba podmienok pre urcenie najlepsej notacie z viacerych pre pouzitie na zapis
##
 #if ( $notationCount > 1 )
  #set( $notationValuedList = ${Utilities.getValuedNotationList(${concept})} )
  #set( $ifBranchToken = "if" )
  #foreach( $notationRank in $notationValuedList )
        $ifBranchToken (
   #set( $notation = $concept.concreteSyntax.get(${notationRank}) )
   #set( $logicalAndOperator = "" )
   #foreach( $notationPart in $notation.parts )
    #if( ${Utilities.getPropertyFromNotationPart(${notationPart},${concept})} )
     #set( $property = ${Utilities.getPropertyFromNotationPart(${notationPart},${concept})} )
     #set( $type = ${property.type} )
     #set( $className = ${Utilities.getClassName($type)} )
     #if( $className == $arrayTypeClassName )
      #set( $hasRangePattern = ${Utilities.hasClassInList(${notationPart.patterns},${rangePatternClassName})} )
      #set( $rangePattern = ${Utilities.getObjectFromList(${notationPart.patterns},${rangePatternClassName})} )
      #if( ${Utilities.getClassName($type.componentType)} == $referenceTypeClassName )
          $logicalAndOperator ${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}() != null
       #if( $hasRangePattern )
          && ${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}().size() >= ${rangePattern.minOccurs}
        #if( $rangePattern.maxOccurs != $rangePatternInfinityValue )
          && ${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}().size() <= ${rangePattern.maxOccurs}
        #end
       #else
          && !${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}().isEmpty()
       #end
      #end
     #elseif( $className == $primitiveTypeClassName )
      #if( ${Utilities.isStringType(${type})} )
          $logicalAndOperator ${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}() != null
      #end
      ## stale to musi mat nejaku hodnotu pri int, real, boolean, cize netreba dalej kontrolovat
     #elseif( $className == $referenceTypeClassName )
           $logicalAndOperator ${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}() != null
     #else
        // not known type for ${property.name}
     #end
     #set( $logicalAndOperator = "&&" )
    #end
   #end
        ) { print${Utilities.toUpperCaseIdent($concept.name)}Notation${notationRank}(${Utilities.toLowerCaseIdent($concept.name)}, p); }
   #set( $ifBranchToken = "else if" )
  #end
        else {
            throw new PrinterException("Cannot find proper notation for printing concept ${concept.name}");
        }
 #end
##
##
## Tvorba samotneho hlavneho tela metody
##
 #if ( $notationCount == 1 )
  #foreach( $notation in $concept.concreteSyntax )
   #foreach( $notationPart in $notation.parts )
    #processNotationPart( $notationPart )
   #end
  #end
 #end
 #if( !$descendants.isEmpty() )
        }
 #end
 #if( $hasParenthesesPattern )
        printNonSpacedLiteral("${parenthesesPattern.right}", p);
 #end
    }

 #if ( $notationCount > 1 )
  #foreach( $notation in $concept.concreteSyntax )
    protected void print${Utilities.toUpperCaseIdent($concept.name)}Notation${concept.concreteSyntax.indexOf(${notation})}(${Utilities.toUpperCaseIdent($concept.name)} ${Utilities.toLowerCaseIdent($concept.name)}, PrintWriter p) {
   #foreach( $notationPart in $notation.parts )
    #processNotationPart( $notationPart )
   #end
    }
  #end
 #end
##
##
## Tvorba metod na prechadzanie polom prvkov v konceptoch
##
 #foreach( $property in $concept.abstractSyntax )
  #set( $type = $property.type )
  #set( $className = ${Utilities.getClassName($type)} )
  #if( $className == $arrayTypeClassName )
   #if( ${Utilities.getClassName($type.componentType)} == $referenceTypeClassName )
    @Override
    protected void visit${Utilities.toUpperCaseIdent($property.name)}In${concept.name}(List<${Utilities.toUpperCaseIdent($type.componentType.concept.name)}> ${Utilities.toLowerCaseIdent($property.name)}, PrintWriter p) {
    #set( $patterns = ${Utilities.getAllPatterns(${property},${concept})} )
    #set( $separator = ${Utilities.getObjectFromList(${patterns},${separatorPatternClassName})} )
    #if( $separator )
        boolean separate = false;
    #end
        for (${Utilities.toUpperCaseIdent($type.componentType.concept.name)} ${Utilities.toLowerCaseIdent($type.componentType.concept.name)} : ${Utilities.toLowerCaseIdent($property.name)}) {
    #if( $separator )
            if (separate) {
                printNonSpacedLiteral("${separator.value}", p);
            }
    #end
            visit${Utilities.toUpperCaseIdent($type.componentType.concept.name)}(${Utilities.toLowerCaseIdent($type.componentType.concept.name)}, p);
    #if( $separator )
            separate = true;
    #end
        }
    }

   #end
  #end
 #end
#end
    public void newLine(PrintWriter p) {
        p.println();
        for (int i = 0; i < indent; i++) {
            p.print(indentString);
        }
        inNewLine = true;
    }

    public void increaseIndent() {
        if (indent != Integer.MAX_VALUE) {
            indent++;
        }
    }

    public void decreaseIndent() {
        if (indent <= 0) {
            indent--;
        }
    }

    public String getIndentString() {
        return indentString;
    }

    public void setIndentString(String indentString) {
        this.indentString = indentString;
    }

    public void printLiteral(String literal, PrintWriter p) {
        if (!inNewLine) {
            p.write(WHITE_SPACE);
        } else {
            inNewLine = false;
        }
        printNonSpacedLiteral(literal, p);
    }

    public void printLiteral(int number, PrintWriter p) {
        printLiteral(String.valueOf(number), p);
    }

    public void printNonSpacedLiteral(String literal, PrintWriter p) {
        p.write(literal);
        if (inNewLine) {
            inNewLine = false;
        }
    }
}
##
##
##
##
##
#macro( processNotationPart $notationPart )
   #set( $hasPatternSupport = ${Utilities.instanceOf(${notationPart},${patternSupportClassName})} )
   #if( $hasPatternSupport )
    #set( $hasNewLinePattern = ${Utilities.hasClassInList(${notationPart.patterns},${newLinePatternClassName})} )
    #set( $hasIndentPattern = ${Utilities.hasClassInList(${notationPart.patterns},${indentPatternClassName})} )
    #if( $hasIndentPattern )
        increaseIndent();
    #end
    #if( $hasNewLinePattern )
        newLine(p);
    #end
   #end
   #set( $notationPartClassName = ${Utilities.getClassName($notationPart)} )
   #if( $notationPartClassName == $tokenPartClassName )
        printLiteral("${notationPart.token}", p);
   #elseif( $notationPartClassName == $propertyReferencePartClassName || $notationPartClassName == $localVariablePartClassName)
    #set( $property = ${Utilities.getPropertyFromNotationPart(${notationPart},${concept})} )
    #set( $type = ${property.type} )
    #set( $className = ${Utilities.getClassName($type)} )
    #if( $className == $arrayTypeClassName )
     #if( ${Utilities.getClassName($type.componentType)} == $referenceTypeClassName )
        visit${Utilities.toUpperCaseIdent($property.name)}In${concept.name}(${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}(), p);
     #end
    #elseif( $className == $primitiveTypeClassName )
        printLiteral(${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($notationPart.property.name)}(), p);
    #elseif( $className == $referenceTypeClassName )
     #if( $notationPartClassName == $localVariablePartClassName )
      ## je potrebne vypisat len hodnotu z Identifier property, kedze je to referencovane len menom v originali
      #set( $propertyWithIdentifier = ${Utilities.getIdentifierProperty(${type.concept})} )
        printLiteral(${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}().get${Utilities.toUpperCaseIdent(${propertyWithIdentifier.name})}(), p);
     #else
##      #set( $hasLocalParenthesesPattern = ${Utilities.hasClassInList(${$type.concept.patterns},${parenthesesPatternClassName})} )
##        #if ( $hasLocalParenthesesPattern )
##
##        #end
        visit${Utilities.toUpperCaseIdent($type.concept.name)}(${Utilities.toLowerCaseIdent($concept.name)}.get${Utilities.toUpperCaseIdent($property.name)}(), p);
     #end
    #else
        // not known type for ${property.name}
    #end
   #else
        // not known type for NotationType
   #end
   #if( $hasPatternSupport )
    #if( $hasIndentPattern )
        decreaseIndent();
    #end
   #end
#end