#summary User Guide for YAJCo tool.

<wiki:toc max_depth="3" />

= User Guide =

_TEMPORARY USER GUIDE_

_WORK IN PROGRESS_

==Main annotations==

===`@Before` and `@After`===
Parameter:
  * `String[] value();`
    * set of actual strings or names of defined tokens
    * main parameter => does not need to be named in code

Describes placement of language tokens in concrete syntax of language. Can be used as annotation on _constructor_, _factory method_ and _parameters_ in constructors and factory methods. Specified tokens in `value` parameter can be:
  * actual textual representation of required tokens
  * names of regex tokens defined with `@TokenDef` inside `@Parser` configuration

{{{
Java:                          |  EBNF:
                               |
@Before("move")                |  Move ::= <move>
Move() {}                      |                       
}}}

{{{
Java:                          |  EBNF:
@Before("iterate")             |  
@After("end")                  |  Iteration ::= <iterate> Expression <times> Statement <end>
Iteration(Expression expr,     |
    @Before("times")           |
    Statement statement) {...} |
}}}
===`@Separator`===
Parameter:
  * `String value();`
    * one string or name of defined tokens to be used as separator in list of elements
    * main parameter => does not need to be named in code

In case you need to specify token for separation of elements used in array or list, this is the annotation you would need.

Use only on parameters of types:
    * array - `Type[]`
    * `List`
    * `Set`

{{{
Java:                          |  EBNF:
@Before("define")              |  
Definition(String ident,       |  Definition ::= <define> IDENT <as> Statement (<;> Statement)*
    @Before("as")              |
    @Range(minOccurs = 1)      |
    @Separator(";")            |
    Statement[] stmts) {...}   |
}}}

===`@Token`===
Parameter:
  * `String value();`
    * one name of defined token to be used as regular expression to parse value for annotated parameter
    * main parameter => does not need to be named in code
Since language concepts can contain not only other concepts, but also primitive values, like numbers and strings, it is needed to specify their concrete notation. This is done by attaching `@Token` annotation with a name of a regular expression as a parameter to the parameter of the constructor. Regular expression have to be specified inside `@TokenDef` in `@Parser` configuration annotation. A string that matches the regular expression is then provided as a value of the parameter.

In addition, if constructor has parameters of primitive Java types like int or double, YAJCo automatically convert matched strings to appropriate type.

`@Token` can be used on parameters of constructors and factory methods only.

===`@Range`===
Parameters:
  * `int minOccurs() default 0;`
    * defines minimal number of occurence of elements in annotated list
  * `int maxOccurs() default -1;`
    * defines maximal number of occurence of elements in annotated list
    * value `-1` is used for _infinity_

A concept can contain multiple instances of subconcepts. This is automatically inferred from the use of array or one of the standard Java collection types. The multiplicity can be restricted using `@Range` annotation.

{{{
Java:                          |  EBNF:
Program(                       |
    @Range(minOccurs = 1)      |  Program ::= Statement+
    Statement[] stmts) {...}   |
}}}
`@Range` can be used on `array`, `List` or `Set` typed parameters of constructors and factory methods only.

===`@Identifier`===
text
===`@References`===
text

===`@Operator`===
Parameters:
  * `int priority() default 1;`
    * defines priority for operator notation, higher number means higher priority
  * `Associativity associativity() default Associativity.AUTO;`
    * defines associativity for operator notation, allowed values are `LEFT`, `RIGHT`, `NONE`, `AUTO` (actually translates to `LEFT`)
Operators represent a type of language constructs that benefits from special treatment. Otherwise they would require more complex definition of concept relations to express rules of priority and associativity.
In YAJCo it is possible to mark concept using `@Operator` annotation and
define its priority and associativity. 

It can be used on constructors.

For better practical understanding, see [Examples#Math_Expression_language Math expression language] in examples or any other more complex example language.

===`@Parentheses`===
Parameters:
  * `String left() default "(";`
    * defines token used for left parentheses, can be specified also as configured named token
  * `String right() default ")";`
    * defines token used for right parentheses, can be specified also as configured named token

Annotation `@Parentheses` can be used to indicate the possibility to use parentheses to explicitly express priority of operators. Usually annotations `@Operator` and `@Parentheses` are used in same language. In practical approach annotation `@Parentheses` is mostly used on abstract classes, which serve as parent for other more specific classes (language concepts).

It can be used on classes.

For better practical understanding, see [Examples#Math_Expression_language Math expression language] in examples or any other more complex example language.

===`@FactoryMethod`===
text
===`@Exclude`===
text


==Config annotations==
text
===`@Parser`===
text
===`@TokenDef`===
text
===`@Skip`===
text
===`@Option`===
text

==Printer annotations==
text
===`@NewLine`===
text
===`@Indent`===
text

==Restrictions==

  * Language concept class must be inside a package. Default package classes are not permitted.
{{{
OK:
  yajco.example.Concept

NOT OK:
  ConceptWithoutPackage
}}}
  * Each language concept class must be in the same package as main (root) language concept or in subpackages. It is not possible to have classes representing language concepts in completely different packages.
{{{
OK:
  yajco.example.MainConcept
  yajco.example.SecondaryConcept
  yajco.example.subpackage.SpecialConcept
  yajco.example.subpackage.subsub.VerySpecialConcept

NOT OK:
  yajco.example.MainConcept
  yajco.special.DifferentConcept
  com.google.SearchConcept
}}}

==IDE how-to==
Using Maven project with YAJCo in most common IDE can provide a lot faster programming, but there are also some possible problems.

===Netbeans===
text

===IntelliJ IDEA===
text

===Eclipse===
text 